###Context sets
ContextSets System Overview
The ContextSets system is a central part of the application's state management, serving as a structured way to store and manage context information used by AI agents.
Structure and State Management
The application uses multiple overlapping state management systems for ContextSets:
Zustand Store (analysis-store.ts):
Primary source of truth for ContextSets
Contains methods for CRUD operations
Handles merging of server and client states
Special handling for disabled context sets
Local Component State (in context-set-component.tsx):
UI-specific state (grid layout, selections, etc.)
Temporary state during editing
Server State:
Persisted context sets stored in database
Accessed via SERVER_getSavedContextSets
Lifecycle of Context Sets
Creation
Added via "add|set" button (addSetToContainer)
Created from agent interactions (via manager directives)
Generated from form submissions (formSchema)
Initially created with empty text/content and default name
Editing
Text can be directly edited in the textarea
Label names can be changed (handleSetLabelName)
Sets can be reordered (shiftSetUpOrDown)
Visibility settings per agent can be toggled (toggleHideFromAgents)
Saving
User clicks "save" button (storeAnalysisSet)
Formats sets, removing invalid properties
Calls handleSaveContextSet from the store
Stores data on server via API call
Updates local contextSetStore with refreshed data
Loading
Selected from dropdown (handleLoadSavedState)
Loaded via handleLoadContextSet
Updates contextSet in localState
Deletion
Three levels of deletion:
Content deletion: Clear content but keep container (deletTextFromSetCalled)
Container deletion: Remove entire container from current set (deleteSetFromContainer)
Saved set deletion: Delete from server storage (handleDeleteSingle/handleDeleteMultipleContextSets)
State Synchronization Issues
I noticed several potential issues in state management:
Multiple sources of truth between local component state and Zustand store
Special handling for "disabled" sets that preserves them even when deleted (which we fixed)
No clear undo/redo capability
Disconnection between server-side context deletion and client-side state updates
The complex state flow appears to be:
Server operations produce context changes
Zustand store receives updates, merges disabled sets
Components render based on store state
User actions update local state, which updates Zustand
Save operations persist to server
This explains why deleting contexts was problematic - deletions on the server weren't properly synchronized with the client's preservation of disabled sets.

Purpose: contextSets serve as the primary mechanism for maintaining shared state, knowledge, and tracking information throughout the orchestration workflow. They allow information gathered or generated by one agent (or the manager) to be made available to others or persisted for future reference.
Management:
The Manager Agent is primarily responsible for creating, updating, and managing context sets.
This is mainly done via the contextSetUpdate field within the structured output (AgentDirectivesSchema defined in agent-execution.ts) returned by ORCHESTRATION_executeManagerTurn.
A fallback mechanism exists (_parseManagerResponse in manager-directed.ts) to parse context updates from text if structured output fails, but structured output is the intended primary method.
Key Operations (via contextSetUpdate):
Creation (newOrUpdate: "new"): Adds a new ContextContainerProps object to the state.contextSets array.
Update (newOrUpdate: "update"): Modifies an existing context set identified by name.
Deletion: Updating an existing set with an empty context string ("") removes that context set from the array.
Empty Set Creation: Attempting to update a non-existent set with an empty context string ("") creates a new, empty context set with the given name.
Visibility Control (visibleToAgents):
The manager specifies visibility using the visibleToAgents field within each context set update directive.
Options: "none", "all", a single agent name (string), or an array of agent names (string[]).
This user-friendly option is converted into the actual hiddenFromAgents: string[] property stored on the ContextContainerProps object within the state.contextSets (logic in manager-directed.ts).
The prompt emphasizes optimizing visibility (avoiding "all" unless necessary) to minimize tokens sent to agents.
Special Context Sets:
"Process Steps": The manager is instructed to create and maintain this set to track workflow progress. Crucially, it should only be visible to the manager itself (visibleToAgents set to the manager's name). Existing steps are treated as suggestions to be adapted.
Form Sets: When the manager sets isInfoRequest: true and directs a message to the user, the ORCHESTRATION_infoRequestToContextFormSet helper function (originally in manager-directed.ts, potentially moved to workflow-helpers.ts) is called. This adds a special form-based context set to state.contextSets before the workflow pauses for user input. The user is also prompted to fill out the form.
Usage by Agents:
When an agent's prompt is generated (ORCHESTRATION_generatePrompt), the relevant context sets (those not hidden from the current agent) are converted into a string format (UTILS_convertLineSetsToContext) and included in the prompt's <SHARED_CONTEXT_SETS> section.
In essence, context sets are dynamically managed key-value stores with fine-grained visibility controls, primarily orchestrated by the manager agent through structured directives to ensure relevant information is shared efficiently and securely within the agent team.
Consistency: The AISessionState type uses the field contextSet: ContextSet;. This aligns perfectly with our previous finding that ContextSet (which wraps an array of ContextContainerProps) is the established type for holding the grouped state of context sets. The type definition itself is consistent and doesn't introduce new conflicting types for context sets.
Redundancy in Store Usage (analysis-store.ts): While the AISessionState type definition is fine, the way it's used in analysis-store.ts reveals redundancy. The store defines both:
localState: AISessionState; (which contains localState.contextSet)
contextSet: ContextSet; (a separate, top-level field)
Looking at the store's implementation:
Actions like handleLoadContextSet and handleTeamAutoGen often update both localState.contextSet and the top-level contextSet with the same data.
This strongly suggests the top-level contextSet field in the store is redundant. The localState object is meant to encapsulate the entire session state, so the context should ideally reside only within localState.contextSet.
Orchestration Settings: It's good that orchestrationSettings are also part of AISessionState. This centralizes session-specific configuration, including orchestration mode and agent lists, which are relevant to how context sets (like visibleToAgents) are processed.
Conclusion:
The AISessionState type definition itself correctly uses the established ContextSet type for managing context. The primary redundancy identified isn't within the type definition but in the Zustand store (analysis-store.ts) implementation, which maintains a duplicate top-level contextSet alongside localState.contextSet.
Recommendation (Incorporating AISessionState):
To simplify:
Simplify AgentTurnResult: As discussed before, streamline how context updates are returned (primarily via agentDirectives.contextSetUpdate, maybe allContextSets).
Refactor analysis-store.ts:
Remove the top-level contextSet: ContextSet; field and its corresponding setContextSet action.
Modify all store actions to read from and write to localState.contextSet exclusively. This makes localState the single source of truth for the session's context.
Addressing the redundancy in the store (analysis-store.ts) by removing the duplicate top-level contextSet would be the most impactful simplification related to AISessionState and context management.