###Context sets
Purpose: contextSets serve as the primary mechanism for maintaining shared state, knowledge, and tracking information throughout the orchestration workflow. They allow information gathered or generated by one agent (or the manager) to be made available to others or persisted for future reference.
Management:
The Manager Agent is primarily responsible for creating, updating, and managing context sets.
This is mainly done via the contextSetUpdate field within the structured output (AgentDirectivesSchema defined in agent-execution.ts) returned by ORCHESTRATION_executeManagerTurn.
A fallback mechanism exists (_parseManagerResponse in manager-directed.ts) to parse context updates from text if structured output fails, but structured output is the intended primary method.
Key Operations (via contextSetUpdate):
Creation (newOrUpdate: "new"): Adds a new ContextContainerProps object to the state.contextSets array.
Update (newOrUpdate: "update"): Modifies an existing context set identified by name.
Deletion: Updating an existing set with an empty context string ("") removes that context set from the array.
Empty Set Creation: Attempting to update a non-existent set with an empty context string ("") creates a new, empty context set with the given name.
Visibility Control (visibleToAgents):
The manager specifies visibility using the visibleToAgents field within each context set update directive.
Options: "none", "all", a single agent name (string), or an array of agent names (string[]).
This user-friendly option is converted into the actual hiddenFromAgents: string[] property stored on the ContextContainerProps object within the state.contextSets (logic in manager-directed.ts).
The prompt emphasizes optimizing visibility (avoiding "all" unless necessary) to minimize tokens sent to agents.
Special Context Sets:
"Process Steps": The manager is instructed to create and maintain this set to track workflow progress. Crucially, it should only be visible to the manager itself (visibleToAgents set to the manager's name). Existing steps are treated as suggestions to be adapted.
Form Sets: When the manager sets isInfoRequest: true and directs a message to the user, the ORCHESTRATION_infoRequestToContextFormSet helper function (originally in manager-directed.ts, potentially moved to workflow-helpers.ts) is called. This adds a special form-based context set to state.contextSets before the workflow pauses for user input. The user is also prompted to fill out the form.
Usage by Agents:
When an agent's prompt is generated (ORCHESTRATION_generatePrompt), the relevant context sets (those not hidden from the current agent) are converted into a string format (UTILS_convertLineSetsToContext) and included in the prompt's <SHARED_CONTEXT_SETS> section.
In essence, context sets are dynamically managed key-value stores with fine-grained visibility controls, primarily orchestrated by the manager agent through structured directives to ensure relevant information is shared efficiently and securely within the agent team.
Consistency: The AISessionState type uses the field contextSet: ContextSet;. This aligns perfectly with our previous finding that ContextSet (which wraps an array of ContextContainerProps) is the established type for holding the grouped state of context sets. The type definition itself is consistent and doesn't introduce new conflicting types for context sets.
Redundancy in Store Usage (analysis-store.ts): While the AISessionState type definition is fine, the way it's used in analysis-store.ts reveals redundancy. The store defines both:
localState: AISessionState; (which contains localState.contextSet)
contextSet: ContextSet; (a separate, top-level field)
Looking at the store's implementation:
Actions like handleLoadContextSet and handleTeamAutoGen often update both localState.contextSet and the top-level contextSet with the same data.
This strongly suggests the top-level contextSet field in the store is redundant. The localState object is meant to encapsulate the entire session state, so the context should ideally reside only within localState.contextSet.
Orchestration Settings: It's good that orchestrationSettings are also part of AISessionState. This centralizes session-specific configuration, including orchestration mode and agent lists, which are relevant to how context sets (like visibleToAgents) are processed.
Conclusion:
The AISessionState type definition itself correctly uses the established ContextSet type for managing context. The primary redundancy identified isn't within the type definition but in the Zustand store (analysis-store.ts) implementation, which maintains a duplicate top-level contextSet alongside localState.contextSet.
Recommendation (Incorporating AISessionState):
To simplify:
Simplify AgentTurnResult: As discussed before, streamline how context updates are returned (primarily via agentDirectives.contextSetUpdate, maybe allContextSets).
Refactor analysis-store.ts:
Remove the top-level contextSet: ContextSet; field and its corresponding setContextSet action.
Modify all store actions to read from and write to localState.contextSet exclusively. This makes localState the single source of truth for the session's context.
Addressing the redundancy in the store (analysis-store.ts) by removing the duplicate top-level contextSet would be the most impactful simplification related to AISessionState and context management.